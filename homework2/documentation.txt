Документация на домашна работа 2

Процес на решението:

Проверка на входните данни:
1. Първо проверявам дали има 3 подадени аргумента, като вторият аргумент не трябва да е distance (това би променило броя на параметрите на 4, защото трябва да се подадат 2 позивни). Ако не са подадени три аргумента като втория не е distance, изписва съобщение за грешка на stderr и излиза с exit status 2.
2. Проверявам за броя на подадените аргументи, като втория трябва да е distance. Ако не са подадени 4 аргумента, изписва съобщение за грешка и излиза с exit status 2.
3. Проверявам дали първият аргумент е обикновен файл и дали има достъп за четене. Ако някое от тези двете не е изпълнено, тогава изписва съобщение за грешка и излиза с exit status 3.
4. Проверявам дали третият аргумент (позивна) съдържа само букви, цифри и "/". Ако съдържа други символи, изписва съобщение за грешка и излиза с exit status 4.
5. Ако броят на аргументите е 4, проверям дали 4-тия (трябва да е позивна) съдържа само букви, цифри и "/". Ако съдържа други символи, изписва съобщение за грешка и излиза с exit status 4.

Промяна на формата на данните:
1. Създавам временен файл с командата mktemp и присвоявам името на този временен файл на променливата TEMP.
2. Проверявам дали променливата CTY_FORMAT има съдържание, което е празен низ - ако е празен низ, най-вероятно не съществува такава променлива, и дали съдържанието е различно от "DAT". Ако това е изпълнено, приемам, че формата на данните е като този от файла "cty.csv".
	2.1.0. При различна стойност на CTY_FORMAT различна от "DAT"
	2.1.1. Взимам колоните, които ми трябват, от файла, подаден като първи аргумент на скрипта, за който се предполага, че е със същия формат като "cty.csv".
	2.1.2. За всеки ред запазвам в променливи името на държавата (COUNTRY), WAZ зоната (WAZ), ITU зоната (ITU), средната географска ширина (WIDTH), средната географска дължина (LENGTH).
	2.1.3. Взимам последната колона (тази с правилата) И разделям всяко правило да е на отделен ред с командата tr - правилата са разделени с " " и с командата tr заменям " " с нов ред. За всяко правило се записва нов ред във временния файл, чието име се пази в променливата TEMP в следния формат: <правило>,<country>,<waz>,<itu>,<width>,<length> 
	2.2.0. При стойност на CTY_FORMAT равна на "DAT"
	2.2.1. Подавам файла, с process substitution на цикъл while, с който го чета ред по ред. Но преди да го подам на цикъла първо малко го променям: Със sed -r "s%\r%%" премахвам carriage return от съдържанието на файла, след това премахвам новите редове (символа "\n") след ":" и след ",", за да може цялата информация за една държава да е на един ред, след това избирам колоните, които ми трябват.
	2.2.2. За всеки ред запазвам в променливи името на държавата (COUNTRY), WAZ зоната (WAZ), ITU зоната (ITU), средната географска ширина (WIDTH), средната географска дължина (LENGTH).
	2.2.3. Взимам последната колона (тази с правилата) И разделям всяко правило да е на отделен ред с командата tr - правилата са разделени с "," и с командата tr заменям " " с нов ред. За всяко правило се записва нов ред във временния файл, чието име се пази в променливата TEMP в следния формат: <правило>,<country>,<waz>,<itu>,<width>,<length> 
3. След изпълнението на тази част вече не ме интересува какъв файл е подаден на скрипта, защото скриптът ще работи само с временния файл, чието име се пази в променливата TEMP.

Описание на функцията mapdata:
Това е функцията, с която определям правилото, според което трябва да се определят данните за местоположението на позивната.
1. На променливата FOUND присвоявам празен низ ("")
2. Проверявам дали съществува правило, което да започва с "=" и да съвапада с позивната, и ако съществува присвоявам реда на променливата FOUND.
3. Проверявам дали низът, който се намира в променливата FOUND е с нулева дължина. Ако не е тогава изписва стойността на FOUND и функцията прекратява изпълнението си.
4. Ако низът, който се намира в променливата FOUND e с нулева дължина, тогава значи не съществува правило, започващо с "=", което да отговаря на разглежданата позивна.
5. На променливата ANS присвоявам празен низ (""), а на променливата COUNT броя на символите (дължината) на позивната.
6. Използвам цикъл, за да намеря най-дългия префикс на позивната, който е и правило.
	6.1. Проверявам дали е COUNT e по-голям от 0. 
	6.2. На променливата PREFIX присвоявам префикса за който ще проверявам дали е правило. Започвам от цялата позивна и после намалям с един символ на всяка итерация на цикъла.
	6.3. На променливата ANS присвоявам получените резултати за текущия PREFIX, който разглеждам.
	6.4. Ако ANS съдържа ненулев низ, тогава значи е намерило съвпадение и съществува правило, което да съвпада с текущата стойност на променливата PREFIX. Изписва стойността на ANS и функцията прекратява изпълнението си.
7. Ако не е прекратила изпълнението си, защото е намерило правило, което да е префикс, тогава връща първия ред файла TEMP.

С case разглеждам различните случаи според това какво е подадено като втори аргумент. Ако не е подадено нещо, което да е сред "country", "zones" или "distance", това ще изведе грешка и ще прекъсне работата на скрипта с exit status 1.

Процес на решението на подточка а:
1. В променливата RESULT записвам резултата от функцията mapdata викната върху файла TEMP и позивната. Така в RESULT се съдържа реда, който е със следния формат "<правило>,<country>,<waz>,<itu>,<width>,<length>".
2. Взимам втората колона спрямо разделител ",", която съдържа името на държава, в която е лицензиран, и го изписвам.

Процес на решението на подточка б:
1. В променливата RESULT записвам резултата от функцията mapdata викната върху файла TEMP и позивната. Така в RESULT се съдържа реда, който е със следния формат "<правило>,<country>,<waz>,<itu>,<width>,<length>".
2. В променливата ITU записвам четвъртата колона спрямо разделител ",", а в променливата WAZ записвам третата колона спрямо разделител ",", а в RULE - първата колона спрямо разделител ",".
3. Проверявам дали в RULE има "(" и ")". Тогава има стойност, която да замени WAZ зоната на държавата и присвоявам тази стойност на променливата WAZ.
4. Проверявам дали в RULE има "[" и "]". Тогава има стойност, която да замени ITU зоната на държавата и присвоявам тази стойност на променливата ITU.
5. Изписвам стойностите на променливите ITU и WAZ.

Процес на решението на подточка в:
1. В променливата RES_A присвоявам резултата от функцията mapdata викната върху файла TEMP и първата позивна, а в RES_B - резултата от функцията mapdata викната върху файла TEMP и втората позивна.
2. В X_A и X_B присвоявам стойностите за географска ширина съответно на първата и втората позивна, а в Y_A и Y_B - стойностите за географска дължина на първата и втората позивна. Тези стойности са в градуси.
3. FI_A, FI_B, THETA_A, THETA_B са променливи, на които присвоявам стойностите на X_A, X_B, Y_A, Y_B, като ги превърна в радиани с помощта на bc -l.
4. Използвам формула, намерена в интернет, с която решавам задачата за намиране на разстоянието между точки в сферични координати.
5. Изписвам разстоянието след като го загръгля до цяло число.

Допълнителна литература: 
https://www.math.ksu.edu/~dbski/writings/haversine.pdf
https://www.shell-tips.com/bash/advanced-math-calculation-in-bash-using-gnu-bc/
https://www.johndcook.com/blog/2010/07/14/bc-math-library/


